# 设计模式与喵格索托斯的泥头车

 > 吼吼哈，你已经被知识追上啦!   
 > 知识的车轮将碾你一脸！

--Meowg·Sothoth

# 负一. 在开始学习之前你得先明白的
在你开始get本文章后续技能时请先确保自己已了解本章节内容，如无法确保请再读一遍，如仍无法确保请再再读一遍，如......
## (-1).1 为什么说面向对象的核心是解耦合
### 面向对象的核心优势
面向对象的优势除了更适宜人类思维方式之外，体现在代码质量上主要有以下三点：
1. 易于维护
2. 更容易实现代码复用
3. 具有更良好的扩展性

而这三点又有一个共同点：都是基于解耦合的方式实现的。
### 解耦合与易维护
易维护从根本上就是建立于解耦合上的，因为解耦合，所以修改的时候只需要修改单独的个别代码块而不需要对整个程序到处编辑
### 解耦合与代码复用
面向对象之所以在代码复用上有优势，是因为存在类的抽象，能够从类的层次进行复用，即“类的复用”，而这一复用的前提是被复用的类本身遵循了SRP设计原则（具体内容见下文(-1).2）,否则一个同时承担了多个功能，各种代码混杂在一起的类基本上复用的收益是很低的。想象一下，你能想像一个类一部分用于界面显示，但这个类里还有半个数据库处理流程和半个压缩包处理，甚至还塞了半截输入输出处理流程吗？你要怎么复用这个类呢？
### 解耦合与代码的扩展性
正是因为有解耦合的存在，每个功能被分开做成不同的模块，代码才称得上有可扩展性——当要扩展某一方面功能的时候只需要修改对应的部分而不需要把整个项目重写一遍。  
如果没有解耦合，所有代码紧密耦合在一起，那就没有可扩展性了，整个项目大改一遍还不如直接重写。
## (-1).2 如何用鞭子抽打大象
## (-1).2.1 两种常见的关系
### (-1).2.1.1 继承
其本质在于实现“XX是YY”的逻辑
### (-1).2.1.2 组合
其本质在于实现“XX有YY”的逻辑
### (-1).2.1.3 你还不懂的话就看这个
**继承**表示一种向下逐渐细分，向上逐渐统一的层级关系，例如猫类可以继承自动物类，因为猫是动物，卡车可以继承自汽车类，因为卡车是汽车，继承关系表示的通常是抽象概念的细化实现与落实，并且具有传递性。如狸花猫是猫，猫是猫科动物，猫科动物是动物。猫科动物是动物的细化落实，猫是猫科动物的细化落实，狸花猫是猫的细化分类落实，并且一通继承下来，最终的猫也还是属于最初的动物。

**组合**表示一种大小包含，模块化构建的层次关系，例如汽车拥有前保险杠，油箱，发动机，变速箱。但变速箱不是汽车，油箱也不是汽车，它们之间有一定关联但并不是继承的关系，而是类似拼图的关系，大的汽车由小的模块化的部件单位组合而成。

**继承**和**组合**不存在优劣关系或者竞争关系，在不同的情况下各自适用，例如一个基本的对话框界面可以继承自视图类（新的对话框是视图），而用户界面里面引用的现有资源则应该以组合方式引用（对话框里有标题框和按钮）
## (-1).2.2 SOLID原则
即，一个良好的面向对象的程序在设计时应遵守以下五大基本原则。  
### S:SRP
**单一职责原则：**“任何一个软件模块都应该只对某一类行为负责”  

就好比服务员不需要炒菜，厨师不需要会算账，采购员不需要会安保。  
一字头改锥不适合用来铲猫砂。  
大家（每个类）都干好自己的活就行了
### O:OCP
**开放封闭原则：**“软件实体应当对扩展开放，对修改关闭”

通俗的来讲，就是当你给程序追加一个新功能，不需要把半个项目都重构一遍。  
尽可能地解耦合并尽可能地在系统架构设计阶段考虑到未来项目可能的发展，从而使追加新功能变得容易，并且减少甚至杜绝新加功能时对已有良好功能的修改。
### L:LSP
**里氏替换原则：**使用基类对象指针或引用的函数必须能够在不了解衍生类的条件下使用衍生类的对象

简单来说就是，继承关系要完全实现**XX是YY**”的关系，例如可乐类继承自液体饮料，那么**可乐是液体饮料**，液体饮料的一切性质可乐都要有，液体饮料可以喝可乐就可以喝，液体饮料是液体可乐就是液体。  
子类必须能够完全替代父类，任何一个地方如果能用父类，放一个子类对象过去也一样可以。  
你不能继承自液体饮料类然后生产一种不能喝的液体饮料，也不能生产一种气体的液体饮料，因为它们不是液体饮料。
### I:ISP
**接口隔离原则：**不应强制客户端依赖于它们不使用的接口

我称之为接口的解耦合。我们不应把一堆乱七八糟的东西塞进同一个接口里，而应该让一个接口做一件专一的事情。  
譬如为`MySQL`提供的接口不需要包含`MongoDB`的实现。  
这样一来一个只使用MySQL的用户就不需要把MongoDB的的功能函数也全都实现一遍。  
这样一来不仅开发便捷，还可以有效减少代码里的垃圾。  

不然的话你的接口就是屎山里屎的源头。
### D:DIP
**依赖倒置原则：**高层次的模块不应该依赖低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象

这个理解之所以称之为倒置原则，是因为它的理论其实挺反直觉的。  
通常来说大家都认为，驱动依赖于硬件，底层依赖于驱动，上层软件代码依赖于底层。如此一层一层依赖，一层一层引用。  
而依赖倒置就是说，我们在设计程序时候不应该自下而上而应该自上而下，在涉及到依赖关系的环节，采取抽象类或者接口的方式进行解耦。这样一来当不同层级出现修改、甚至出现功能变化时，就不需要其他层级也跟着大改。  
比如货物的运输依赖于物理的运输方式，你直接写死运输方式为卡车，并且把卡车的具体功能函数写进来，过段时间底层增加了海运，你就得把整个货物运输重写一遍，然后加入火车时候再重写一遍，引入飞机航运时候再重写一遍。  
而你如果一开始写的是货物运输依赖于运输方式类，然后在运输方式类里实现卡车接口，等其他功能进来你只需要在运输方式类里面加加加就行了。

# 一. 创建型模式
## 1.1 泥头车创创子，零落成泥碾做尘
> 创建型模式提供了创建对象的机制，从而将对象的创建与使用分离，能够提升代码的可拓展性并更容易实现代码复用。

怎么样，被术语创到没（doge）  
理解简化版：创建型模式：把对象创建和使用解耦合
### <font color=red> 1.1.@#$%^ 简%……&单【【错误！】】工厂模【删除】式
#### 警告：该模式违反 SRP 单一职责原则，是一种错误范式。它不是一个真正的设计模式，仅仅是工厂模式的前身</font>
简单工厂模式并不在设计模式列表里，也不是一种正式的设计模式，在这里添加这一小节仅仅是为了便于你更容易了解后文的工厂模式。因此请务必记住 **简单工厂不是设计模式，简单工厂模式是错误的！**

所谓简单工厂模式就是说，有一个“工厂”能够根据用户的需求提供不同的“产品实例”  
例如：  
我们有一个饮料类，并且有两个子类`糯香柠檬茶`和`崂山蛇草水`，你有时候想喝`糯香柠檬茶`，有时候想喝`崂山蛇草水`，而这个时候你有一个室友大爹（工厂），根据你不同的要求，他会给你带回对应的洗袜子水——我是说饮料。

### 1.1.1 工厂方法（函数）模式
在上一个【错误】模式中，我们已经把`糯香柠檬茶`和`崂山蛇草水`抽象出了饮料的层级，这使得你想要再追加新饮品譬如`恒河水`的时候不需要触碰已有的饮料相关类，然而由于你的`室友大爹代购`函数和`糯香柠檬茶`与`崂山蛇草水`直接耦合，这导致你每当想喝不同的东西，就得修改一遍`室友大爹代购`函数，增加一种新的`饮料`。

因此工厂方法（函数）模式就是在这个基础上，把你的室友大爹代购函数也抽象出来，把它做成一个接口。然后你就可以写两个室友大爹代购函数的实现类，分别是`室友大爹喂我喝糯香柠檬水`和`室友大爹喂我喝崂山蛇草水`。

然后你自己的室友大爹代购函数自身是个抽象接口（或者父类），根据 LSP 原则，不管是`室友大爹喂我喝糯香柠檬水`还是`室友大爹喂我喝崂山蛇草水`都可以直接接替进来。并且当你需要追加一种新饮料的时候，只需要创建两个新类`恒河水`和`室友大爹喂我喝恒河水`即可，原有的功能代码全部不需要改动。（良好的符合 OCP 原则的实现）
### 1.1.2 抽象工厂模式
上一节的工厂模式只能提供一个大类的产品（饮料），而抽象工厂模式，就是工厂接口提供更多的产品大类。  
通俗的来讲，就是你的室友大爹除了给你带“饮料”，还能给你带“盖饭”
### 1.1.3 生成器模式
如果说上述模式是为了解决产品与用户之间解耦合的话，那么生成器模式（也称建造者模式），就是为了实现复杂产品或自定义产品（总之就是同一类但有部分差别的产品）的生产问题。  
这里用饭店炒菜来举例子。  
你创建了一个“出餐”函数对用户提供产品，通过输入不同的产品要求和工序参数，用户能够获得各自不同需求的产品。  
比如`酸辣土豆丝不要醋和土豆丝`、`麻辣豆腐不要花椒和辣椒`、`葱花饼不要放葱花`、`鱼香肉丝里多加芝士和腐竹`等等。  
(别问，问就是客人是上帝，甲方是大爷)  
于是为了适应不同用户的需求，你最终会写出一个巨大巨大巨大巨大的出餐函数。  
而这时候来了一个脑子正常的甲方A，他想买一份宫保鸡丁。  
他看着有两万多个参数的出餐函数陷入了沉思。  
然后开始填写：“不要酸辣土豆丝，不要麻婆豆腐，不要馅饼，不要鱼香茄子，要宫保鸡丁，不加辣椒，不加土豆丝，不加盘子，不加餐具吗，不加杯子，不要炒米饭，不要炒面，要米饭，不要饼，要油炒，要鸡丁，要花生米，要糖，不要腐竹，不加茄丁......”  
而这时候来了一个脑子正常的甲方B，他想买一个馒头。  
两个小时之后，流程还没执行完。  
第二天，接到过多投诉的你因为左脚先迈进公司被董事会开除。

发现这个函数的问题了吗？出餐这个概念的设计的东西太多了！

我们完全可以给每个菜单独抽离出来，出餐的地方配置一大组接口，用户用什么就去调用对应的工序，比如用户可以先添加`宫保鸡丁基本工序`，再添加一个`炒制过程加入茄丁`附加工序，就得到了`加茄丁的宫保鸡丁`。  

而且也不用买个馒头都跑一遍完整工序了。

后续追加菜品也容易了，新加接口就行，不用把巨大巨大巨大巨大的函数再改一遍。
### 1.1.4 单例模式
单例模式从理解的方面来说，其实核心思想就是：“只有一个我”，这样一来就可以解决两个问题：
1. 有些类只能有一个实例，例如一个操作系统只能有一个id生成器（否则两个生成器生成的id可能重复），或者有些你到处使用的工具类来回创建销毁对象会导致很大的资源开销，那就不如保留一个实例一直用。
2. 有些东西你定义成全局变量很容易被局部变量给覆盖了导致访问不到，而单例模式是无法拷贝也无法生成新实例的，因此不管在任何作用域如何访问，都能只能访问同一个实例。

从概念上来说，其本质就是：  
你只能被创造（出生）一次。  
从此之后不管谁找你，找到的都是你，因为你是唯一的。

从实现的角度来说，就是把实际的真构造函数设置为私有，并且存储一个提供一个指向实例的指针，然后对外提供的构造函数有条件的引用这个构造函数。

当实例不存在（世界上还没有你）就创造一个你，并且把你的位置存储进指针，当实例存在（世界上已经有你），就返回实例引用（告诉调用者你的位置）
### 1.1.5 原型模式
原型模式取自于设备开发的“原型机”概念。  
要便于理解的话其实使用“基础模板”这个说法更好理解。

当我们拥有一个“模板”，就可以参照模板生成出一模一样的产品（或半成品）。  

例如假如我们有一个笔记本电脑模板了，它包含主板屏幕金属外壳和薄膜键盘以及触摸板。但并没有cpu和显卡网卡硬盘内存。  
我们可以根据这个模板，生产出大量的半成品，然后为它们插上不同的cpu和显卡网卡硬盘内存，成为不同配置的产品。  
这样一来我们甚至可以简化一些类和及其子类的构造  
并且采取这种方式的话，我们甚至连未提供拷贝构造函数的类的外部无法访问的那些私有变量都可以拷贝复制。

而且原型的实现也非常简单，只要提供一个“自我复函数”就行了（当然，为了便于使用，最好设计的时候就提供一个统一的“自我复制接口”，然后在各个原型类继承接口并实现）
# 二. 结构型模式
### 1.1.1 适配器模式
适配器，又名转换器，转接器，转接头。  
用来解决实际输入和提供的接口不适配的问题。  
例如最常见的把三孔电源插座转换成两孔插座的转接头，就是一种适配器。  
又比如接口只接受json数据，实际上报的却是xml，那么中间加的这个格式转换的类就叫做适配器

显然的，通过增加适配器类，可以避免对已有的两端代码的修改，并且避免了可能合
### 1.1.2 装饰器模式

### 1.1.3 代理模式

### 1.1.4 外观模式

### 1.1.5 桥接模式

### 1.1.6 组合模式

### 1.1.7 享元模式

# 三. 行为型模式
### 1.1.1 策略模式

### 1.1.2 模板方法模式

### 1.1.3 观察者模式

### 1.1.4 迭代子模式

### 1.1.5 责任链模式

### 1.1.6 命令模式

### 1.1.7 备忘录模式

### 1.1.8 状态模式

### 1.1.9 访问者模式

### 1.1.10 中介者模式

### 1.1.11 解释器模式

